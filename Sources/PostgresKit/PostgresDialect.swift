import SQLKit

public struct PostgresDialect: SQLDialect {
    public init() {}
    
    public var name: String { "postgresql" }

    public var identifierQuote: any SQLExpression { SQLRaw(#"""#) }

    public var literalStringQuote: any SQLExpression { SQLRaw("'") }

    public var supportsAutoIncrement: Bool { true }

    public var autoIncrementClause: any SQLExpression { SQLRaw("GENERATED BY DEFAULT AS IDENTITY") }

    public var autoIncrementFunction: (any SQLExpression)? { nil }

    public func bindPlaceholder(at position: Int) -> any SQLExpression { SQLRaw("$\(position)") }

    public func literalBoolean(_ value: Bool) -> any SQLExpression { SQLRaw("\(value)") }

    public var literalDefault: any SQLExpression { SQLRaw("DEFAULT") }

    public var supportsIfExists: Bool { true }

    public var enumSyntax: SQLEnumSyntax { .typeName }

    public var supportsDropBehavior: Bool { true }

    public var supportsReturning: Bool { true }

    public var triggerSyntax: SQLTriggerSyntax {
        .init(
            create: [.supportsForEach, .postgreSQLChecks, .supportsCondition, .conditionRequiresParentheses, .supportsConstraints],
            drop: [.supportsCascade, .supportsTableName]
        )
    }

    public var alterTableSyntax: SQLAlterTableSyntax {
        .init(
            alterColumnDefinitionClause: SQLRaw("ALTER COLUMN"),
            alterColumnDefinitionTypeKeyword: SQLRaw("SET DATA TYPE")
        )
    }

    public func customDataType(for dataType: SQLDataType) -> (any SQLExpression)? { nil }

    public var upsertSyntax: SQLUpsertSyntax { .standard }

    public var unionFeatures: SQLUnionFeatures {
        [.union, .unionAll, .intersect, .intersectAll, .except, .exceptAll, .explicitDistinct, .parenthesizedSubqueries]
    }

    public var sharedSelectLockExpression: (any SQLExpression)? { SQLRaw("FOR SHARE") }

    public var exclusiveSelectLockExpression: (any SQLExpression)? { SQLRaw("FOR UPDATE") }
}
